// xs snow [Size] [Color] [Colors] [Seed]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Size'  var = 'm_size'  range = '0 31'  value = '13'  step = '1'  precision = '0' }
// arg : { name = 'Symmetry'  var = 'm_symmetry'  range = '0 2'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Intensity'  var = 'm_intensity'  range = '0 255'  value = '100'  step = '1'  precision = '0' }
// arg : { name = 'Color'  var = 'm_color'  range = '0 255'  value = '156'  step = '1'  precision = '0' }
// arg : { name = 'Color Range'  var = 'm_colors'  range = '0 255'  value = '8'  step = '1'  precision = '0' }
// arg : { name = 'Seed'  var = 'm_seed' range = '0 2147483647'  value = '1'  step = '1'  precision = '0' }
// xs_end

int size = int(m_size);
float intensity = m_intensity / 100;

float hash(vec2 p, float seed) {
	p += seed;
	return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

float get_colour(int x, int y, int z) {
    if (m_symmetry == 0)
    {
        if (x >= 128)
        {
            x = 255 - x;
            y = 255 - y;
        }
        if (y >= 128)
        {
            int t = x;
            x = 255 - y;
            y = t;
        }
    }
    float j = hash(vec2(x, y), m_seed);
    float k = hash(vec2(j, z), int(m_seed) ^ 0x1357);
    return k;
}

float map(vec3 v) {
	float index = voxel(v);

	int x = v.x;
	int y = v.y;
	int z = v.z;

    float total = 0;
    float total_weight = 0;
    float total_var = 0;
    float ss = pow(size, 2);
    for (int dx = -size; dx <= size; ++dx)
        for (int dy = -size; dy <= size; ++dy)
            for (int dz = -size; dz <= size; ++dz) {
                float dd = dx * dx + dy * dy + dz * dz;
                if (dd > ss) continue;
                int new_x = (x + dx + 256) % 256;
                int new_y = (y + dy + 256) % 256;
                int new_z = (z + dz + 256) % 256;
                float k = get_colour(new_x, new_y, new_z);
                float weight = (ss - dd) / (dd + ss);

                total += k * weight;
                total_weight += weight;
                total_var += 0.25 * pow(weight, 2);
            }
    total /= total_weight;
    total_var /= pow(total_weight, 2);

	if (index != 0) {
        total = int(((total - 0.5) / sqrt(total_var) * 0.31 * intensity + 0.5) * m_colors);
        if (total < 0) {
            total = 0;
        }
        if (total >= m_colors) {
            total = m_colors - 1;
        }
        return m_color + total;
	}
	return index;
}
