// xs snow [Size] [Color] [Colors] [Seed]
//
// xs_begin
// author : '@lachlanmcdonald'
// arg : { name = 'Size'  var = 'm_size'  range = '0 31'  value = '13'  step = '1'  precision = '0' }
// arg : { name = 'Style'  var = 'm_symmetry'  range = '0 1'  value = '1'  step = '1'  precision = '0' }
// arg : { name = 'Seed'  var = 'm_inner_seed' range = '0 2147483647'  value = '0'  step = '1'  precision = '0' }
// arg : { name = 'Intensity'  var = 'm_intensity'  range = '0 4'  value = '1'  step = '0.1'  precision = '2' }
// arg : { name = 'Color'  var = 'm_color'  range = '0 255'  value = '156'  step = '1'  precision = '0' }
// arg : { name = 'Color Range'  var = 'm_colors'  range = '0 255'  value = '8'  step = '1'  precision = '0' }
// arg : { name = 'Color Offset'  var = 'm_offset'  range = '-255 255'  value = '0'  step = '0.01'  precision = '2' }
// arg : { name = 'Margin Seed'  var = 'm_seed' range = '0 2147483647'  value = '42'  step = '1'  precision = '0' }
// arg : { name = 'Noise'  var = 'm_noise' range = '0 1000'  value = '10'  step = '1'  precision = '0' }
// xs_end

int size = int(m_size);

float hash(vec2 p, float seed) {
	p += seed;
	return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));
}

float get_colour(int x, int y, int z) {
    // Symmetry mode 0: no tiling
    if (m_symmetry == 0)
    {
        float j = hash(vec2(x, y), m_inner_seed);
        float k = hash(vec2(j, z), int(m_inner_seed) ^ 0x1357);
        return k;
    }
    else
    // Symmetry mode 1: general tiling
    {
        if (x < m_size || y < m_size || 255 - x < m_size || 255 - y < m_size)
        {
            if (x >= 128)
            {
                x = 255 - x;
                y = 255 - y;
            }
            if (y >= 128)
            {
                int t = x;
                x = 255 - y;
                y = t;
            }
            float j = hash(vec2(x, y), m_seed);
            float k = hash(vec2(j, z), int(m_seed) ^ 0x1357);
            return k;
        }
        else
        {
            float j = hash(vec2(x, y), m_inner_seed);
            float k = hash(vec2(j, z), int(m_inner_seed) ^ 0x1357);
            return k;
        }
    }
}

float map(vec3 v) {
	float index = voxel(v);

	int x = v.x;
	int y = v.y;
	int z = v.z;

    float total = 0;
    float total_weight = 0;
    float total_var = 0;
    float ss = pow(size, 2);
    for (int dx = -size; dx <= size; ++dx)
        for (int dy = -size; dy <= size; ++dy)
            for (int dz = -size; dz <= size; ++dz) {
                float dd = dx * dx + dy * dy + dz * dz;
                if (dd > ss) continue;
                int new_x = (x + dx + 256) % 256;
                int new_y = (y + dy + 256) % 256;
                int new_z = (z + dz + 256) % 256;
                float k = get_colour(new_x, new_y, new_z);
                float weight = (ss - dd) / (dd + ss);
                if (dx == 0 && dy == 0 && dz == 0)
                {
                    weight += m_noise;
                }

                total += k * weight;
                total_weight += weight;
                total_var += 0.25 * pow(weight, 2);
            }
    total /= total_weight;
    total_var /= pow(total_weight, 2);

	if (index != 0) {
        total = int(((total - 0.5) / sqrt(total_var) * 0.31 * m_intensity + 0.5) * m_colors + m_offset);
        if (total < 0) {
            total = 0;
        }
        if (total >= m_colors) {
            total = m_colors - 1;
        }
        return m_color + total;
	}
	return index;
}
